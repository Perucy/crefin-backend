# ============================================================================
# ENVIRONMENT VARIABLES - Configuration Template
# ============================================================================

# WHAT IS THIS FILE?
# This is a TEMPLATE showing what environment variables your app needs.
# Think of it like a shopping list - it shows what ingredients you need,
# but doesn't contain the actual ingredients.
#
# WHY DO WE NEED ENVIRONMENT VARIABLES?
# Different environments (development, production) need different values:
# - Development: localhost database, fake API keys, debug mode ON
# - Production: real database, real API keys, debug mode OFF
#
# IMPORTANT: This file (.env.example) is committed to git
#           The actual .env file is NEVER committed (contains real secrets!)

# ============================================================================
# HOW TO USE THIS FILE
# ============================================================================

# STEP 1: Copy this file to create your real .env file
# $ cp .env.example .env

# STEP 2: Replace placeholder values in .env with real values
# Example:
# JWT_SECRET=your_secret_here  ❌ BAD (placeholder)
# JWT_SECRET=a8f5d9c7b3e2f1...  ✅ GOOD (real secret)

# STEP 3: NEVER commit .env to git!
# It's already in .gitignore, but double-check!

# ============================================================================
# APPLICATION SETTINGS
# ============================================================================

# WHAT ENVIRONMENT ARE WE RUNNING IN?
# Options: development | production | test
#
# WHY IT MATTERS:
# - development: Shows detailed errors, auto-reloads code, verbose logging
# - production: Hides sensitive errors, optimized, minimal logging
# - test: Uses test database, mocks external APIs
#
# HOW IT'S USED:
# if (process.env.NODE_ENV === 'production') {
#   // Hide error details from users
# } else {
#   // Show full stack traces for debugging
# }
NODE_ENV=development

# WHAT PORT SHOULD THE SERVER LISTEN ON?
# Default: 3000 (common for Node.js apps)
#
# WHY CONFIGURABLE?
# - Different developers might have port 3000 taken
# - Production might use port 80 (HTTP) or 443 (HTTPS)
# - Docker containers might map different ports
#
# ALTERNATIVES:
# - 3000: Most common for Node.js
# - 8080: Common for web servers
# - 5000: Common for APIs
PORT=3000

# API VERSION (for URL structure)
# Example: /api/v1/auth/login
#
# WHY VERSION APIS?
# - Can release v2 without breaking v1 clients
# - Mobile apps can't force users to update
# - Gradual migration (v1 → v2)
API_VERSION=v1

# BASE URL OF YOUR API
# Used for: Email links, CORS, webhooks, etc.
#
# DEVELOPMENT: http://localhost:3000
# PRODUCTION: https://api.freelancehub.com
#
# WHY IMPORTANT?
# When sending password reset emails, you need to include a link:
# "Click here to reset: ${APP_URL}/reset-password?token=..."
APP_URL=http://localhost:3000

# BASE URL OF YOUR FLUTTER APP
# Used for: CORS (allowing your app to call this API)
#
# DEVELOPMENT: http://localhost:5173 (or wherever Flutter dev server runs)
# PRODUCTION: https://freelancehub.com
CLIENT_URL=http://localhost:5173

# ============================================================================
# DATABASE (PostgreSQL)
# ============================================================================

# DATABASE CONNECTION STRING
# Format: postgresql://USERNAME:PASSWORD@HOST:PORT/DATABASE_NAME
#
# BREAKDOWN:
# postgresql://        Protocol (PostgreSQL)
# freelancehub         Username (who to login as)
# :dev_password...     Password (change this!)
# @localhost           Host (where database is running)
# :5432                Port (PostgreSQL default)
# /freelancehub_dev    Database name
#
# SECURITY WARNING:
# NEVER use simple passwords like "password123" in production!
# Use randomly generated passwords (32+ characters)
#
# DEVELOPMENT:
DATABASE_URL=postgresql://freelancehub:dev_password_change_in_prod@localhost:5432/freelancehub_dev

# PRODUCTION EXAMPLE (DO NOT USE THIS EXACT VALUE):
# DATABASE_URL=postgresql://prod_user:Xy9$mK2!pL5@db.example.com:5432/freelancehub_prod

# DATABASE CONNECTION POOL SETTINGS
# Connection pooling reuses database connections (faster!)
#
# HOW IT WORKS:
# Without pooling: Open connection → Query → Close connection (slow!)
# With pooling: Get from pool → Query → Return to pool (fast!)
#
# MIN CONNECTIONS: Always keep this many open (default: 2)
# MAX CONNECTIONS: Never open more than this (default: 10)
#
# WHY LIMITS?
# - Too few: Requests wait for available connections (slow)
# - Too many: Overwhelms database (crashes)
#
# RULE OF THUMB:
# Max = (number of app servers) × 10
# Example: 3 servers × 10 = 30 max connections
DATABASE_POOL_MIN=2
DATABASE_POOL_MAX=10

# ============================================================================
# REDIS CACHE
# ============================================================================

# REDIS CONNECTION STRING
# Format: redis://HOST:PORT
#
# WHY REDIS?
# - Super fast (in-memory storage)
# - Cache expensive database queries
# - Store session data
# - Rate limiting counters
#
# EXAMPLE USE CASE:
# Market rates change every 15 minutes, but users search every second.
# Instead of hitting database 1000 times, cache the result in Redis!
#
# DEVELOPMENT:
REDIS_URL=redis://localhost:6379

# PRODUCTION WITH PASSWORD:
# REDIS_URL=redis://:your_redis_password@redis.example.com:6379

# HOW LONG TO CACHE DATA (in seconds)
# 900 seconds = 15 minutes
#
# WHY 15 MINUTES?
# - Market rates don't change every second
# - 15 min is fresh enough for users
# - Dramatically reduces database load
#
# TRADEOFF:
# - Shorter TTL: More accurate, but slower (more DB queries)
# - Longer TTL: Faster, but data might be stale
REDIS_TTL=900

# ============================================================================
# JWT (JSON Web Tokens) - Authentication
# ============================================================================

# JWT SECRET KEY FOR ACCESS TOKENS
# THIS IS THE MOST IMPORTANT SECRET IN YOUR APP!
#
# WHAT IS IT?
# Used to sign and verify JWT tokens (like a wax seal on a letter)
# If someone gets this secret, they can impersonate any user!
#
# HOW TO GENERATE (Node.js):
# node -e "console.log(require('crypto').randomBytes(64).toString('hex'))"
#
# REQUIREMENTS:
# - Minimum 32 characters (64+ recommended)
# - Random (not a password you can remember)
# - Different for access and refresh tokens
# - NEVER commit to git
# - NEVER share with anyone
# - NEVER log this value
#
# WHAT HAPPENS IF LEAKED?
# Attacker can:
# - Create tokens for any user
# - Access any account
# - You must rotate (change) the secret immediately
# - All users need to login again
JWT_SECRET=your_super_secret_key_change_this_in_production_min_32_chars

# JWT REFRESH TOKEN SECRET
# Different secret for refresh tokens (extra security layer)
#
# WHY SEPARATE?
# If access token secret is leaked, refresh tokens still safe
# (And vice versa)
JWT_REFRESH_SECRET=your_refresh_secret_key_change_this_too_min_32_chars

# HOW LONG UNTIL ACCESS TOKEN EXPIRES?
# Format: 15m = 15 minutes, 1h = 1 hour, 7d = 7 days
#
# ACCESS TOKEN: Short-lived (15 minutes)
# WHY SHORT?
# - Sent with every API request
# - More likely to be intercepted
# - If stolen, attacker only has 15 minutes
#
# TRADEOFF:
# - Too short (5m): Users constantly re-login (annoying)
# - Too long (1h): More time for attackers (dangerous)
# - 15m is industry standard sweet spot
JWT_EXPIRES_IN=15m

# HOW LONG UNTIL REFRESH TOKEN EXPIRES?
# REFRESH TOKEN: Long-lived (7 days)
#
# WHY LONGER?
# - Used less frequently (only when access token expires)
# - Stored more securely (not sent with every request)
# - Better user experience (don't login for a week)
#
# TRADEOFF:
# - Too short (1h): Users re-login constantly
# - Too long (30d): Stolen tokens work for a month
# - 7d is common (balance security + UX)
JWT_REFRESH_EXPIRES_IN=7d

# ============================================================================
# RATE LIMITING (Prevent API Abuse)
# ============================================================================

# TIME WINDOW FOR RATE LIMITING (milliseconds)
# 900000 ms = 15 minutes
#
# HOW IT WORKS:
# Track requests per user in this time window
# Example: 100 requests per 15 minutes
#
# WHY 15 MINUTES?
# - Long enough for normal usage
# - Short enough to stop brute force attacks
# - Industry standard
RATE_LIMIT_WINDOW_MS=900000

# MAXIMUM REQUESTS PER WINDOW (Free users)
# 100 requests = ~7 requests/minute (normal usage)
#
# EXAMPLES:
# Login page: 1 request
# Load dashboard: 5 requests (user, stats, notifications, etc.)
# Search rates: 1 request
#
# 100 requests is generous for legitimate users
#
# WHAT HAPPENS WHEN EXCEEDED?
# User gets 429 Too Many Requests error
# "Try again in X minutes"
RATE_LIMIT_MAX_REQUESTS=100

# MAXIMUM REQUESTS FOR PREMIUM USERS
# 1000 requests = 10x more than free users
#
# WHY?
# - Premium users pay for better service
# - Might have automation/integrations
# - Still prevents abuse (not unlimited)
RATE_LIMIT_PREMIUM_MAX=1000

# ============================================================================
# EXTERNAL APIs (Third-Party Services)
# ============================================================================

# UPWORK API (for fetching market rates)
# Sign up at: https://www.upwork.com/developer/
#
# WHY UPWORK?
# - Largest freelance marketplace
# - Has market rate data
# - Public API available
#
# HOW TO GET CREDENTIALS:
# 1. Create Upwork account
# 2. Go to Developer settings
# 3. Create new app
# 4. Copy Client ID and Secret
UPWORK_CLIENT_ID=your_upwork_client_id
UPWORK_CLIENT_SECRET=your_upwork_client_secret
UPWORK_API_URL=https://www.upwork.com/api

# VENMO API (for payments)
# Note: Venmo doesn't have a public API yet!
#
# ALTERNATIVES FOR MVP:
# - Stripe: Most popular, easy to integrate
# - PayPal: Widely trusted
# - Plaid: For bank transfers
#
# FOR NOW:
# We'll log payments manually, add real payments later
VENMO_CLIENT_ID=your_venmo_client_id
VENMO_CLIENT_SECRET=your_venmo_client_secret
VENMO_API_URL=https://api.venmo.com/v1

# ============================================================================
# EMAIL (SendGrid for notifications)
# ============================================================================

# SENDGRID API KEY
# Sign up at: https://sendgrid.com (free tier: 100 emails/day)
#
# USED FOR:
# - Welcome emails
# - Password reset
# - Payment notifications
# - Weekly summaries
SENDGRID_API_KEY=your_sendgrid_api_key

# EMAIL "FROM" ADDRESS
# Must be verified in SendGrid
# Example: noreply@freelancehub.com
FROM_EMAIL=noreply@freelancehub.com
FROM_NAME=FreelanceHub

# ============================================================================
# MONITORING & LOGGING
# ============================================================================

# LOG LEVEL
# Options: debug | info | warn | error
#
# debug: Everything (very verbose)
# info: Important events (user login, API calls)
# warn: Potential issues (slow queries, deprecated features)
# error: Only errors
#
# DEVELOPMENT: debug (see everything)
# PRODUCTION: info or warn (less noise)
LOG_LEVEL=debug

# SENTRY DSN (Error Tracking)
# Sign up at: https://sentry.io (free tier available)
#
# WHAT IS SENTRY?
# Tracks errors in production:
# - Stack traces
# - User context
# - Frequency of errors
# - Alerts when errors spike
#
# WHY YOU NEED THIS:
# In production, you can't just console.log() and look at terminal!
# Sentry emails you when something breaks.
SENTRY_DSN=your_sentry_dsn_for_error_tracking

# ============================================================================
# STRIPE (Payment Processing)
# ============================================================================

# STRIPE SECRET KEY
# Sign up at: https://stripe.com
#
# TYPES OF KEYS:
# - Test keys (sk_test_...): For development (no real money)
# - Live keys (sk_live_...): For production (real money!)
#
# NEVER mix test and live keys!
STRIPE_SECRET_KEY=sk_test_your_stripe_secret_key

# STRIPE WEBHOOK SECRET
# Used to verify webhook events are from Stripe
#
# WHAT ARE WEBHOOKS?
# Stripe sends HTTP POST to your server when:
# - Payment succeeds
# - Subscription renewed
# - Payment failed
#
# WHY VERIFY?
# Anyone could POST to your webhook URL
# This secret proves it's actually from Stripe
STRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret

# STRIPE PRICE ID (for $4.99/month premium)
# Create in Stripe dashboard: Products → Add Product
# Copy the Price ID (starts with price_...)
STRIPE_PREMIUM_PRICE_ID=price_your_premium_price_id

# ============================================================================
# SECURITY
# ============================================================================

# CORS ALLOWED ORIGINS (comma-separated)
# Which websites can call your API?
#
# WHAT IS CORS?
# Browser security that blocks requests from other domains
# Example: freelancehub.com can't call api.competitor.com
#
# WHY CONFIGURE?
# You want YOUR Flutter app to call YOUR API
#
# DEVELOPMENT: http://localhost:5173
# PRODUCTION: https://freelancehub.com
#
# NEVER use "*" (allows any website!)
CORS_ORIGINS=http://localhost:5173,http://localhost:3000

# MINIMUM PASSWORD LENGTH
# 8 characters is industry minimum
#
# ALTERNATIVES:
# - 6: Too weak (easily cracked)
# - 10: More secure (but users complain)
# - 8: Good balance
MIN_PASSWORD_LENGTH=8

# BCRYPT ROUNDS (Password hashing strength)
# How many times to hash the password
#
# TRADEOFF:
# - Higher = More secure, but slower
# - 10 rounds = ~100ms (good for most apps)
# - 12 rounds = ~400ms (high security)
# - 14 rounds = ~1.6s (too slow for login)
#
# RULE: Should take 100-300ms
# As computers get faster, increase this number
BCRYPT_ROUNDS=10

# ============================================================================
# FEATURE FLAGS (Turn features on/off)
# ============================================================================

# ENABLE AI FEATURES?
# Turn off if Python microservice isn't ready yet
ENABLE_AI_FEATURES=true

# ENABLE PAYMENTS?
# Turn off until Venmo/Stripe integration is complete
ENABLE_PAYMENTS=false

# ENABLE EMAIL?
# Turn off until SendGrid is configured
ENABLE_EMAIL=false

# ============================================================================
# DEVELOPMENT TOOLS (DO NOT USE IN PRODUCTION!)
# ============================================================================

# SHOW DETAILED ERRORS?
# true = Show full stack traces to API clients
# false = Hide sensitive info ("Internal server error")
#
# SECURITY WARNING:
# Showing stack traces in production leaks:
# - File paths
# - Database structure
# - Code logic
# 
# ONLY USE IN DEVELOPMENT!
ENABLE_DEBUG_MODE=true

# AUTO-SEED DATABASE ON STARTUP?
# Adds test users/data automatically
#
# USEFUL FOR:
# - Development (fresh data every restart)
# - Demo environments
#
# NEVER USE IN PRODUCTION! (overwrites real data)
AUTO_SEED_DB=false

# ============================================================================
# WHAT YOU LEARNED
# ============================================================================

# ✅ Environment variables separate config from code
# ✅ .env.example is a template (committed to git)
# ✅ .env has real secrets (NEVER committed)
# ✅ Different environments need different values
# ✅ Secrets should be long and random
# ✅ Never hardcode API keys in source code
# ✅ Use feature flags to turn things on/off

# ============================================================================
# NEXT STEPS
# ============================================================================

# 1. Copy this file:
#    $ cp .env.example .env

# 2. Generate JWT secrets:
#    $ node -e "console.log(require('crypto').randomBytes(64).toString('hex'))"
#    Copy output and paste into .env for JWT_SECRET

# 3. Generate another for JWT_REFRESH_SECRET:
#    $ node -e "console.log(require('crypto').randomBytes(64).toString('hex'))"

# 4. Verify .env is in .gitignore:
#    $ cat .gitignore | grep .env
#    Should see: .env

# 5. NEVER commit .env to git!

# NEXT FILE: .gitignore (tell git what NOT to commit)